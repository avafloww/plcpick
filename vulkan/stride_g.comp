#version 460
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
layout(local_size_x = 1) in;

#include "secp256k1.glsl"

// Input: stride value as U256
layout(std430, set = 0, binding = 0) readonly buffer StrideIn {
    uint stride_val[8]; // U256 LE limbs
};

// Output: stride as U256 (8 uints), stride_G as JacobianPoint (24 uints)
layout(std430, set = 0, binding = 1) buffer StrideOut {
    uint stride_data[8];
    uint stride_g_data[24]; // x[8], y[8], z[8]
};

// g_table: 15 affine points = 240 uints
layout(std430, set = 0, binding = 2) readonly buffer GTable {
    uint g_table_data[240];
};

void main() {
    U256 s;
    for (int i = 0; i < 8; i++) s.d[i] = stride_val[i];

    // Copy stride to output
    for (int i = 0; i < 8; i++) stride_data[i] = s.d[i];

    // Load g_table
    AffinePoint g_table[15];
    for (int i = 0; i < 15; i++) {
        for (int j = 0; j < 8; j++) {
            g_table[i].x.d[j] = g_table_data[i * 16 + j];
            g_table[i].y.d[j] = g_table_data[i * 16 + 8 + j];
        }
    }

    // Compute stride * G
    JacobianPoint result;
    secp_scalar_mul_G(result, s, g_table);

    // Write JacobianPoint
    for (int i = 0; i < 8; i++) {
        stride_g_data[i] = result.x.d[i];
        stride_g_data[8 + i] = result.y.d[i];
        stride_g_data[16 + i] = result.z.d[i];
    }
}
